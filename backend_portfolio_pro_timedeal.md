# 🚀 프로젝트 명: TimeDeal Pro (대규모 트래픽 대응 커머스 엔진)

## 1. 프로젝트 개요
**TimeDeal Pro**는 초당 수천 건의 트래픽이 집중되는 선착순 구매 환경을 가정하여 설계된 고성능 백엔드 시스템입니다.
단순 CRUD를 넘어 **데이터 일관성 모델, 조회 성능 튜닝, 복잡한 비즈니스 정책의 객체지향적 분리**를 심도 있게 다룹니다.

---

## 2. 데이터베이스 모델링 (7 Tables)
1. **Users:** 기본 정보 및 포인트 잔액.
2. **Items:** 상품 정보, 가격, **정적/동적 상태 관리**.
3. **Categories:** **Self-Join을 통한 무제한 계층 구조**.
4. **Coupons:** 발급 제한 수량, **유효 기간 정책**, 할인 정책.
5. **UserCoupons:** 발급 이력, 사용 일시, **주문과의 연관 관계**.
6. **Orders:** 결제 금액 계산 로직이 포함된 핵심 엔티티.
7. **Payments:** **상태 머신(State Machine)** 기반의 결제 이력 관리.

---

## 3. 핵심 문제 해결 및 기술적 의사결정 기록 (Resume Points)

### ✅ 시나리오 1: 초고동시성 환경에서의 재고 및 쿠폰 정합성
* **문제 발견:** 수천 명의 사용자가 0.1초 사이에 동시에 요청할 때, DB의 원자적 업데이트만으로는 데이터 오염(Race Condition)을 막을 수 없음.
* **선택지 탐색:**
    1. **Java `synchronized` / `ReentrantLock`:** 자바 수준의 락 사용.
    2. **데이터베이스 낙관적 락 (Optimistic Lock):** `@Version`을 이용한 어플리케이션 수준 제어.
    3. **데이터베이스 비관적 락 (Pessimistic Lock):** `SELECT ... FOR UPDATE`를 통한 배타적 잠금.
* **장단점 분석:**
    - `synchronized`: 서버가 다중화되는 순간(Scale-out) 무용지물이 됨.
    - `낙관적 락`: 충돌이 잦은 '선착순' 환경에서는 재시도(Retry) 로직이 과도해져 성능이 급격히 저하됨.
    - `비관적 락`: DB에 부하를 주지만, 충돌이 빈번한 환경에서 데이터 정합성을 가장 확실히 보장하며 순차 처리가 가능함.
* **최종 선택 및 이유:** **비관적 락(Pessimistic Lock) 선정.** 선착순 이벤트의 특성상 충돌 발생률이 100%에 가깝기 때문에, 실패 후 재시도하는 비용보다 처음부터 락을 통해 대기시키는 것이 데이터 무결성과 전체 성능 면에서 유리하다고 판단함.

### ✅ 시나리오 2: 복합적인 할인 정책과 확장성 있는 설계
* **문제 발견:** 정액, 정률 할인 외에 '첫 구매 할인', '카테고리별 특가' 등 정책이 늘어날수록 주문 서비스 코드가 스파게티화됨.
* **선택지 탐색:**
    1. **주문 서비스 내 대형 `switch-case` 문:** 모든 로직을 한 곳에 집중.
    2. **템플릿 메서드 패턴 (Template Method Pattern):** 상속을 통한 할인 로직 구현.
    3. **전략 패턴 (Strategy Pattern) + 퍼사드(Facade):** 인터페이스 기반 정책 분리.
* **장단점 분석:**
    - `switch-case`: 구현은 빠르나 새로운 정책 추가 시 기존 코드를 수정해야 함(OCP 위반).
    - `템플릿 메서드`: 상속 계층이 깊어지면 유연성이 떨어지고 컴파일 시점에 구조가 고정됨.
    - `전략 패턴`: 각 할인 정책을 독립된 클래스로 관리하여 런타임에 동적으로 교체 가능하며 테스트가 용이함.
* **최종 선택 및 이유:** **전략 패턴 및 퍼사드 패턴 선정.** 정책의 변화가 잦은 커머스 특성상 확장성을 최우선으로 고려함. 할인 계산 로직을 별도 엔진으로 분리하여 `OrderService`의 책임을 줄이고 유지보수성을 극대화함.

### ✅ 시나리오 3: 대량 데이터 조회 성능 최적화 (인덱스 전략)
* **문제 발견:** 상품 데이터가 100만 건 이상일 때, 카테고리별 검색 및 정렬 조회 시 쿼리 타임아웃 발생.
* **선택지 탐색:**
    1. **애플리케이션 단에서 정렬 (Memory Sort):** DB 쿼리 후 자바에서 처리.
    2. **단일 컬럼 인덱스 (Single Index):** 자주 검색되는 각 컬럼에 개별 인덱스 부여.
    3. **복합 인덱스 (Composite Index) + 커버링 인덱스 (Covering Index):** 쿼리에 최적화된 복합 구조.
* **장단점 분석:**
    - `메모리 정렬`: 데이터가 많아질 경우 서버 메모리 부족(OOM) 위험이 큼.
    - `단일 인덱스`: 여러 조건이 붙을 때 효율이 떨어지며 인덱스 머지 비용 발생.
    - `복합 인덱스`: 조회 조건 순서에 맞춘 인덱스 설계로 Full Scan을 방지하고 성능을 극적으로 향상시킴.
* **최종 선택 및 이유:** **복합 인덱스 및 QueryDSL 최적화 선정.** `(category_id, status, created_at)` 순으로 인덱스를 구성하여 필터링과 정렬을 동시에 해결. `EXPLAIN`을 통해 쿼리 실행 계획을 분석하여 인덱스 타는 것을 검증함.

### ✅ 시나리오 4: 주문 상세 정보 조회 시 N+1 문제 고도화 해결
* **문제 발견:** 주문 내역 조회 시 연관된 유저, 상품, 결제 정보를 가져오기 위해 1+N번의 쿼리가 발생하여 성능 저하.
* **선택지 탐색:**
    1. **즉시 로딩 (Eager Loading):** JPA 설정으로 항상 함께 조회.
    2. **페치 조인 (Fetch Join):** JPQL을 사용하여 한 번에 조인 쿼리 실행.
    3. **Batch Size 설정 (`@BatchSize`):** 설정된 개수만큼 `IN` 쿼리로 나누어 조회.
* **장단점 분석:**
    - `즉시 로딩`: 불필요한 데이터까지 항상 로딩되어 성능 예측이 어려움.
    - `페치 조인`: 가장 확실한 해결책이지만, '다(Many)' 쪽 엔티티가 둘 이상일 때 카테시안 곱 이슈로 페이징 불가.
    - `Batch Size`: 페이징 쿼리를 유지하면서도 N+1 문제를 1+1 정도로 줄여주는 균형 잡힌 대안.
* **최종 선택 및 이유:** **Fetch Join과 Batch Size 병행 사용.** 단일 연관 관계는 `Fetch Join`으로 해결하고, 페이징이 필요한 컬렉션 조회는 `default_batch_fetch_size`를 통해 최적화하여 조회 효율과 안정성을 모두 확보함.

### ✅ 시나리오 5: 결제 프로세스의 안정성 및 가상 외부 시스템 연동
* **문제 발견:** 결제 도중 시스템 장애 발생 시 주문 상태와 결제 상태가 불일치하는 현상(결제는 됐는데 주문은 실패 등) 방지 필요.
* **선택지 탐색:**
    1. **단순 트랜잭션 묶기:** 모든 로직을 하나의 `@Transactional`에 넣기.
    2. **2단계 커밋 (2PC):** 분산 트랜잭션 프로토콜 사용.
    3. **상태 머신 및 유효성 검증 패턴:** 단계별 상태 저장 및 사후 검증.
* **장단점 분석:**
    - `단순 트랜잭션`: 외부 시스템 연동 시 트랜잭션이 길어져 커넥션 풀 고갈 위험.
    - `2PC`: 구현이 매우 복잡하고 시스템 성능 저하가 심함.
    - `상태 검증`: 주문을 '결제대기' 상태로 생성 후, 가상 결제 완료 시 '결제확인'으로 변경하며 금액 정합성을 검증함.
* **최종 선택 및 이유:** **상태 머신 기반 검증 패턴 선정.** 실제 커머스 환경을 모사하기 위해 결제 전후의 데이터 정합성(최종 결제 금액 vs 주문 금액 일치 여부)을 체크하는 검증 로직을 추가하여 시스템 안정성을 높임.

---

## 4. Junie(AI) 코딩 가이드

1. **QueryDSL Advanced:** "단순 조회가 아니라, `BooleanExpression`을 분리해서 재사용 가능한 동적 쿼리 구조로 `ItemRepositoryCustom`을 구현해줘."
2. **Locking & Test:** "비관적 락을 적용한 `CouponService`를 만들고, `CountDownLatch`와 `ExecutorService`를 사용해 100개의 스레드가 동시에 접근할 때 정확히 재고만큼만 차감되는지 검증하는 테스트 코드를 짜줘."
3. **Hierarchical Category:** "Self-Join을 활용하여 카테고리를 계층 구조로 조회할 수 있는 로직을 만들고, 상위 카테고리 조회 시 하위 카테고리 상품까지 포함될 수 있도록 처리해줘."
4. **Validation:** "주문 생성 시 상품 가격과 쿠폰 할인액이 반영된 최종 금액이 DB에 저장된 값과 일치하는지 검증하는 `OrderValidator` 클래스를 만들어줘."